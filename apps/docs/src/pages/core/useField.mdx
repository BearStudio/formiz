import { Type } from '@/components/Type';
import { CodeEditor } from '@/components/CodeEditor';
import { useFieldFile } from '@/templates/useField.ts';

# useField

## Hooks methods

### setValue()

<Type type="(fieldValue : any) => void" />
Set the value of the field.

```tsx
const MyField = (props) => {
  const { setValue } = useField(props);

  return <input onChange={(e) => setValue(e.target.value)} />;
};
```

setValue also accept a function that gives the previous value (like React setState).

```tsx
setValue((previousValue) => {
  // ...
  // Your logic
  // ...
  return newValue;
});
```

### setIsTouched()

<Type type="(isTouched : boolean) => void" />
Set the value isTouched of the field.

```tsx
const MyField = (props) => {
  const { setIsTouched } = useField(props);

  setIsTouched(true);

  return <input />;
};
```

## Hook values

### value

Get the current value of the field.

```tsx
const MyField = (props) => {
  const { value } = useField(props);

  return <input value={value ?? ''} />;
};
```

### id

<Type type="number" />
Return a unique id. This id will be created based on the form id and the field name.

```tsx
const MyField = (props) => {
  const { id } = useField(props)

  return (
    <label htmlFor={id}>...</label>
    <input id={id} />
  )
}
```

### isTouched

<Type type="boolean" />

Returns `true` if the field has been touched.

```jsx
const { isTouched } = useField(props);
```

### isValid

<Type type="boolean" />

Returns `true` if the field is valid.

```jsx
const { isValid } = useField(props);
```

### isValidating

<Type type="boolean" />

Returns `true` if the field is running async validation.

```jsx
const { isValidating } = useField(props);
```

### isPristine

<Type type="boolean" />

Returns `true` if the field has not been changed.

```jsx
const { isPristine } = useField(props);
```

### isSubmitted

<Type type="boolean" />

Returns `true` either if the current step or the form is submitted.

```jsx
const { isSubmitted } = useField(props);
```

### shouldDisplayError

<Type type="boolean" />

Returns `true` if the field should display an error, usefull when debugging.

```jsx
const { shouldDisplayError } = useField(props);
```

### errorMessage

<Type type="string | undefined" />

Returns the first error message.

```jsx
const { errorMessage } = useField(props);
```

### errorMessages

<Type type="string[] | undefined" />

Returns all error messages.

```jsx
const { errorMessages } = useField(props);
```

### resetKey

<Type type="number" />

Returns the number of time the form has been resetted.

```jsx
const { resetKey } = useField(props);

useEffect(() => {
  /* Do a side effect on reset */
}, [resetKey]);
```

## Hook extra values

### otherProps

<Type type="FieldProps" />

Get the props passed to the component without the Formiz props.
Allows you to keep composition by spreading this object in your component.

```jsx
const MyField = (props) => {
  const { otherProps } = useField(props);

  return <Box {...otherProps}>{/* Field */}</Box>;
};
```

---

## Field props

### name \*

<Type type="string" />

**Required**

The name is required to register the field in the form.

```jsx
<Field name="myFieldName" />
```

**Nested objects**

The `name` props can use lodash-like dot paths to reference nested values.

```jsx
<Field name="fieldA" />
<Field name="fieldB" />
<Field name="myGroup.fieldA" />
<Field name="myGroup.fieldB" />

/* Form values
{
  fieldA: 'value',
  fieldB: 'value',
  myGroup: {
    fieldA: 'value',
    fieldB: 'value',
  },
}
*/
```

**Arrays**

The `name` props allow also arrays and arrays of objects out of the box.
Using lodash-like bracket syntax for `name` allow you to handle fields in a list.

```jsx
<Field name="myArray[0]" />
<Field name="myArray[1]" />
<Field name="myArrayOfObjects[0].fieldA" />
<Field name="myArrayOfObjects[0].fieldB" />
<Field name="myArrayOfObjects[1].fieldA" />
<Field name="myArrayOfObjects[1].fieldB" />

/* Form values
{
  myArray: ['value', 'value'],
  myArrayOfObjects: [
    { fieldA: 'value', fieldB: 'value' },
    { fieldA: 'value', fieldB: 'value' },
  ],
}
*/
```

### defaultValue

Pass an initial value to the field.

```tsx
<Field name="myFieldName" defaultValue="My initial value" />
```

### formatValue(fieldValue)

<Type type="(fieldValue) => string | null" />

Format the value before saving it into the internal state.

```jsx
<Field name="myFieldName" formatValue={(val) => (val || '').trim()} />
```

### onChange(fieldValue)

<Type type="(fieldValue) => void" />

```jsx
<Field name="myFieldName" onChange={(val) => console.log(val)} />
```

### required

<Type type="boolean" />

Shortcut for isRequired() validation

```jsx
<Field name="myFieldName" required="Field is required" />
```

### debounceValidationsAsync

Number of milliseconds for debouncing validations. (default is `100`).

```jsx
<Field name="myFieldName" debounceValidationsAsync={200} />
```

### validations

Accept an array of object with the following keys:

- `rule(fieldValue)`: Built in validation rule or custom validation function (must returns `true` if the rule is valid).
- `deps`: Array of external values used in the rule function (like array of dependencies in useEffect).
- `message`: The message if the rule is invalid.

```jsx
<Field
  name="myFieldName"
  validations={[
    {
      rule: isRequired(),
      message: 'Field is required',
    },
    {
      rule: isNotEmptyString(),
      message: "Field can't be empty",
    },
    {
      rule: (value) => value.toLowerCase() !== 'john',
      message: "Field can't be john",
    },
    {
      rule: (value) => value !== externalValue,
      deps: [externalValue],
      message: "Field can't be the same as external value",
    },
  ]}
/>
```

### validationsAsync

Async validations allows you to run asynchronous code to validate a field, such as an API call.
`validationsAsync` will only be triggered if all the others `validations` rules are valid.

Accept an array of object with the following keys:

- `rule(fieldValue)`: Must returns a **Promise** that returns `true` if the rule is valid.
- `deps`: Array of external values used in the rule function (like array of dependencies in useEffect).
- `message`: The message if the rule is invalid.

```jsx
<Field
  name="myFieldName"
  validationsAsync={[
    {
      rule: async (value) => {
        const isAlreadyUsed = await validateUsername(value);
        return isAlreadyUsed;
      },
      message: 'Username already used, please select another one.',
    },
  ]}
/>
```

## <CodeEditor files={useFieldFile} />

TODO :
[ ] get information if you let informations config section

# Field config

### ✨ formatValue

### ✨ required

### ✨ validations

### ✨ validationsAsync

### ✨ debounceValidationsAsync

### ✨ unstable_notifyOnChangePropsExclusions
